Principales Características:

  Control Cluster K8S:
	Puede correr en el mismo o external.
	Soporta cualquier tipo de manifest
	Cuando crear una Argo CD APP, definis un REPO GIT y un namespace y el lo instala
	Monitora el repo GIT, si encuentra algún cambio lo actualiza en el cluster para dejarlos sync.
	

Argo CD is just one member of the Argo family of projects. These are:

Argo CD (GitOps controller)
Argo Rollouts (Progressive Delivery controller)
Argo Workflows (Workflow engine for Kubernetes)
Argo Events (Event handling for Kubernetes)

Exposing your Argo CD to users will be a different process depending on your organization, but in most cases, you should make the Argo CD UI available to external traffic via a Kubernetes ingress.

Once the external URL is ready, you need to decide how users will access the Argo CD UI. There are mainly two approaches:

Use a small number of local users. Authentication is handled by Argo CD itself. Best for very small companies (e.g. 2-5 people).
Use an SSO provider. Authentication is handled by the provider. Ideal for companies and large organizations
	
The possible values are:

“Healthy” -> Resource is 100% healthy
“Progressing” -> Resource is not healthy but still has a chance to reach healthy state
“Suspended” -> Resource is suspended or paused. The typical example is a cron job
“Missing” -> Resource is not present in the cluster
“Degraded” -> Resource status indicates failure or resource could not reach healthy state in time
“Unknown” -> Health assessment failed and actual health status is unknown

The decision whether an application is healthy or not depends on the type of underlying Kubernetes resources.

For the built-in Kubernetes resources, the rules are the following:

Deployments, ReplicaSets, StatefulSets, and Daemon sets are considered “healthy” if observed generation is equal to desired generation.
Number of updated replicas equals the number of desired replicas.

For a service of type Loadbalancer or Ingress, the resource is healthy if the status.loadBalancer.ingress list is non-empty, with at least one value for hostname or IP.

For custom Kubernetes resources, health is defined in Lua scripts. Some examples of resources that have custom health definitions are:
Argo Rollout (and associated Analysis and Experiments)
Bitnami Sealed secrets
Cert Manager
Elastic Search
Jaeger
Kafka
CrossPlane provider

There are 3 parameters that you can change when defining the sync strategy:
Manual or automatic sync.
Auto-pruning of resources - this is only applicable for automatic sync.
Self-Heal of cluster - this is only applicable for automatic sync.

Self-heal defines what Argo CD does when you make changes directly to the cluster (via kubectl or any other way). Note that doing manual changes in the cluster is not recommended if you want to follow GitOps principles (as all changes should pass from Git). If enabled, then Argo CD will discard the extra changes and bring the cluster back to the state described in Git.

The truth is that there is no single accepted practice for how secrets are managed with GitOps. If you already have a solid solution in place such as HashiCorp vault, then it would make sense to use that even though technically it is against GitOps practices.


Principales Características:

  Control Cluster K8S:
	Puede correr en el mismo o external.
	Soporta cualquier tipo de manifest
	Cuando crear una Argo CD APP, definis un REPO GIT y un namespace y el lo instala
	Monitora el repo GIT, si encuentra algún cambio lo actualiza en el cluster para dejarlos sync.
	

Argo CD is just one member of the Argo family of projects. These are:

Argo CD (GitOps controller)
Argo Rollouts (Progressive Delivery controller)
Argo Workflows (Workflow engine for Kubernetes)
Argo Events (Event handling for Kubernetes)

Exposing your Argo CD to users will be a different process depending on your organization, but in most cases, you should make the Argo CD UI available to external traffic via a Kubernetes ingress.

Once the external URL is ready, you need to decide how users will access the Argo CD UI. There are mainly two approaches:

Use a small number of local users. Authentication is handled by Argo CD itself. Best for very small companies (e.g. 2-5 people).
Use an SSO provider. Authentication is handled by the provider. Ideal for companies and large organizations
	
The possible values are:

“Healthy” -> Resource is 100% healthy
“Progressing” -> Resource is not healthy but still has a chance to reach healthy state
“Suspended” -> Resource is suspended or paused. The typical example is a cron job
“Missing” -> Resource is not present in the cluster
“Degraded” -> Resource status indicates failure or resource could not reach healthy state in time
“Unknown” -> Health assessment failed and actual health status is unknown

The decision whether an application is healthy or not depends on the type of underlying Kubernetes resources.

For the built-in Kubernetes resources, the rules are the following:

Deployments, ReplicaSets, StatefulSets, and Daemon sets are considered “healthy” if observed generation is equal to desired generation.
Number of updated replicas equals the number of desired replicas.

For a service of type Loadbalancer or Ingress, the resource is healthy if the status.loadBalancer.ingress list is non-empty, with at least one value for hostname or IP.

For custom Kubernetes resources, health is defined in Lua scripts. Some examples of resources that have custom health definitions are:
Argo Rollout (and associated Analysis and Experiments)
Bitnami Sealed secrets
Cert Manager
Elastic Search
Jaeger
Kafka
CrossPlane provider

There are 3 parameters that you can change when defining the sync strategy:
Manual or automatic sync.
Auto-pruning of resources - this is only applicable for automatic sync.
Self-Heal of cluster - this is only applicable for automatic sync.

Self-heal defines what Argo CD does when you make changes directly to the cluster (via kubectl or any other way). Note that doing manual changes in the cluster is not recommended if you want to follow GitOps principles (as all changes should pass from Git). If enabled, then Argo CD will discard the extra changes and bring the cluster back to the state described in Git.

The truth is that there is no single accepted practice for how secrets are managed with GitOps. If you already have a solid solution in place such as HashiCorp vault, then it would make sense to use that even though technically it is against GitOps practices.

Progressive Delivery is the practice of deploying an application in a gradual manner allowing for minimum downtime and easy rollbacks. There are several forms of progressive delivery such as blue/green, canary, a/b and feature flags.


